//
// Copyright (C) 2025 Dmitry Kolesnikov
//
// This file may be modified and distributed under the terms
// of the MIT license.  See the LICENSE file for details.
// https://github.com/fogfish/cloudmcp
//

package cloudmcp

import (
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
	"time"

	"github.com/aws/aws-cdk-go/awscdk/v2/awsiam"
	"github.com/aws/aws-cdk-go/awscdk/v2/awslambda"
	"github.com/aws/constructs-go/constructs/v10"
	"github.com/fogfish/scud"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// Factory is a function that constructs instance of MCP Server.
//
//	func HelloWorld() (*mcp.Server, error) {
//		server := mcp.NewServer(...)
//		mcp.AddTool(server, ...)
//		return server, nil
//	}
type Factory = func() (*mcp.Server, error)

// ServerProps defines properties for MCP Server as a Lambda function.
// This construct assumes a function is running an instance of MCP Server.
type ServerProps struct {
	*scud.FunctionGoProps
	Factory Factory
	AutoGen bool
}

// Helper utility to bind scud.FunctionGoProps with MCP Server Factory.
func NewServerProps(f Factory, props *scud.FunctionGoProps) *ServerProps {
	return &ServerProps{
		FunctionGoProps: props,
		Factory:         f,
	}
}

// Force regeneration of the server binding code on each deployment.
func (f *ServerProps) ForceAutoGen() *ServerProps {
	f.AutoGen = true
	return f
}

// L3 Construct for MCP Server as AWS Lambda function.
// This construct assumes a function is running an instance of MCP Server.
type Server struct {
	uri      string
	Function awslambda.Function
}

// Defines MCP Server as a Lambda function.
func NewServer(scope constructs.Construct, id *string, spec *ServerProps) *Server {
	name, path := sautogen(spec.Factory, spec.SourceCodeModule, spec.AutoGen)
	uri := "/" + strings.ToLower(name)
	spec.SourceCodeLambda = filepath.Join(path, serverdir)
	flambda := scud.NewFunctionGo(scope, id, spec.FunctionGoProps)

	return &Server{uri: uri, Function: flambda}
}

// Grants public access to the server via given public authorizer.
func (c *Server) AllowAccessPublic(api *scud.AuthorizerPublic) {
	api.AddResource(c.uri, c.Function)
}

// Grants access to the server via given API key authorizer.
func (c *Server) AllowAccessApiKey(api *scud.AuthorizerBasic) {
	api.AddResource(c.uri, c.Function)
}

// Grants access to the server via given JWT authorizer.
func (c *Server) AllowAccessJWT(api *scud.AuthorizerJwt, scope ...string) {
	api.AddResource(c.uri, c.Function, scope...)
}

// Grants access to the server via given IAM authorizer.
func (c *Server) AllowAccessIAM(api *scud.AuthorizerIAM, principal awsiam.IGrantable) {
	api.AddResource(c.uri, c.Function, principal)
}

//------------------------------------------------------------------------------

const serverdir = "autogen"

func sautogen(f Factory, scModule string, force bool) (string, string) {
	fptr := reflect.ValueOf(f).Pointer()
	fobj := runtime.FuncForPC(fptr)
	if fobj == nil {
		panic(fmt.Errorf("failed to discover function metadata"))
	}

	name := fobj.Name()
	serv := filepath.Ext(name)[1:]
	path := strings.TrimSuffix(name, filepath.Ext(name))
	base := filepath.Base(name)

	code := fmt.Sprintf(`// DO NOT EDIT !!!
// THE FILE IS AUTO GENERATED BY github.com/fogfish/cloudmcp
// %s
package main

import (
	"net/http"

  "github.com/aws/aws-lambda-go/lambda"
	"github.com/fogfish/cloudmcp/internal/gateway"
	"github.com/modelcontextprotocol/go-sdk/mcp"
	"%s"
)

func main() {
	server, err := %s()
	if err != nil {
		panic(err)
	}

	handler := mcp.NewStreamableHTTPHandler(func(*http.Request) *mcp.Server {
		return server
	}, &mcp.StreamableHTTPOptions{
		Stateless:    true,
		JSONResponse: true,
	})

	srv := gateway.New(handler)

	lambda.Start(srv.Serve)
}
`, time.Now(), path, base)

	gofile, _ := fobj.FileLine(fptr)
	codepath := filepath.Join(filepath.Dir(gofile), serverdir, "main.go")

	if !force {
		if _, err := os.Stat(codepath); err == nil {
			// If the file already exists, we assume it has been generated before
			return serv, strings.TrimPrefix(path, scModule)
		}
	}

	err := os.MkdirAll(filepath.Dir(codepath), 0766)
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(codepath, []byte(code), 0766)
	if err != nil {
		panic(err)
	}

	return serv, strings.TrimPrefix(path, scModule)
}
