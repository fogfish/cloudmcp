//
// Copyright (C) 2025 Dmitry Kolesnikov
//
// This file may be modified and distributed under the terms
// of the MIT license.  See the LICENSE file for details.
// https://github.com/fogfish/cloudmcp
//

package cloudmcp

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strings"
	"time"

	"github.com/aws/aws-cdk-go/awscdk/v2/awsiam"
	"github.com/aws/aws-cdk-go/awscdk/v2/awslambda"
	"github.com/aws/constructs-go/constructs/v10"
	"github.com/fogfish/scud"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// Signature for type-safe entry point to lambda function
type Lambda[A, B any] = func(context.Context, *mcp.CallToolRequest, A) (*mcp.CallToolResult, B, error)

// FunctionProps defines properties for MCP Tool Function as a Lambda function.
// The properties are type-safe declaration for MCP tool inptut and output types.
// The construct assumes a function is running as an instance of MCP Server, it performs
// automatic code generation for binding the function into MCP Server.
type FunctionProps[A, B any] struct {
	*scud.FunctionGoProps
	Handler Lambda[A, B]
	About   string
	AutoGen bool
}

// Helper for NewFunctionProps to support automatic inference of types from function
func NewFunctionProps[A, B any](f Lambda[A, B], about string, props *scud.FunctionGoProps) *FunctionProps[A, B] {
	return &FunctionProps[A, B]{
		FunctionGoProps: props,
		Handler:         f,
		About:           about,
	}
}

// Force regeneration of the function binding code on each deployment.
func (f *FunctionProps[A, B]) ForceAutoGen() *FunctionProps[A, B] {
	f.AutoGen = true
	return f
}

// L3 Construct for MCP Tool Function as AWS Lambda function.
// This construct assumes a function is running as an instance of MCP Server.
type Function[A, B any] struct {
	uri      string
	Function awslambda.Function
}

// Defines MCP Tool Function as a Lambda function.
func NewFunction[A, B any](scope constructs.Construct, id *string, spec *FunctionProps[A, B]) *Function[A, B] {
	name, path := fautogen(spec.Handler, spec.About, spec.SourceCodeModule, spec.AutoGen)
	uri := "/" + strings.ToLower(name)
	spec.SourceCodeLambda = filepath.Join(path, funcdir)
	flambda := scud.NewFunctionGo(scope, id, spec.FunctionGoProps)

	return &Function[A, B]{uri: uri, Function: flambda}
}

// Grants public access to the function via given public authorizer.
func (c *Function[A, B]) AllowAccessPublic(api *scud.AuthorizerPublic) {
	api.AddResource(c.uri, c.Function)
}

// Grants access to the function via given API key authorizer.
func (c *Function[A, B]) AllowAccessApiKey(api *scud.AuthorizerBasic) {
	api.AddResource(c.uri, c.Function)
}

// Grants access to the function via given JWT authorizer.
func (c *Function[A, B]) AllowAccessJWT(api *scud.AuthorizerJwt, scope ...string) {
	api.AddResource(c.uri, c.Function, scope...)
}

// Grants access to the function via given IAM authorizer.
func (c *Function[A, B]) AllowAccessIAM(api *scud.AuthorizerIAM, principal awsiam.IGrantable) {
	api.AddResource(c.uri, c.Function, principal)
}

//------------------------------------------------------------------------------

const funcdir = "autogen"

func fautogen[A, B any](f Lambda[A, B], about, scModule string, force bool) (string, string) {
	fptr := reflect.ValueOf(f).Pointer()
	fobj := runtime.FuncForPC(fptr)
	if fobj == nil {
		panic(fmt.Errorf("failed to discover function metadata"))
	}

	name := fobj.Name()
	serv := filepath.Ext(name)[1:]
	path := strings.TrimSuffix(name, filepath.Ext(name))
	base := filepath.Base(name)

	code := fmt.Sprintf(`// DO NOT EDIT !!!
// THE FILE IS AUTO GENERATED BY github.com/fogfish/cloudmcp
// %s
package main

import (
	"net/http"

  "github.com/aws/aws-lambda-go/lambda"
	"github.com/fogfish/cloudmcp/internal/gateway"
	"github.com/modelcontextprotocol/go-sdk/mcp"
	"%s"
)

func main() {
	server := mcp.NewServer(
		&mcp.Implementation{Name: "%s", Version: "v0.0.0"},
		nil,
	)
	mcp.AddTool(server, &mcp.Tool{Name: "%s", Description: "%s"}, %s)

	handler := mcp.NewStreamableHTTPHandler(func(*http.Request) *mcp.Server {
		return server
	}, &mcp.StreamableHTTPOptions{
		Stateless:    true,
		JSONResponse: true,
	})

	srv := gateway.New(handler)

	lambda.Start(srv.Serve)
}
`, time.Now(), path, serv, serv, about, base)

	gofile, _ := fobj.FileLine(fptr)
	codepath := filepath.Join(filepath.Dir(gofile), serverdir, "main.go")

	if !force {
		if _, err := os.Stat(codepath); err == nil {
			// If the file already exists, we assume it has been generated before
			return serv, strings.TrimPrefix(path, scModule)
		}
	}

	err := os.MkdirAll(filepath.Dir(codepath), 0766)
	if err != nil {
		panic(err)
	}
	err = os.WriteFile(codepath, []byte(code), 0766)
	if err != nil {
		panic(err)
	}

	return serv, strings.TrimPrefix(path, scModule)
}
